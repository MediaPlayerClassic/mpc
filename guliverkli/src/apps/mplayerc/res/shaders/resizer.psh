sampler s0 : register(s0);
sampler s1 : register(s1);
sampler s2 : register(s2);

float4 p0  : register(c0);
float2 dxdy : register(c1);
float2 dx : register(c2);
float2 dy : register(c3);

#define size (p0.xy)
#define	A _The_Value_Of_A_Is_Set_Here_

// none of the resizers here can be used for 1:1 mapping! 
// tex * size won't be 0, 1, 2, 3, .. as you might expect, but something like 0, 0.999, 2.001, 2.999, ...
// this means when the fractional part becomes 0.999 we will be interpolating with the wrong value!!!

float4 main_bilinear(float2 tex : TEXCOORD0) : COLOR
{
	tex -= 0.5*dxdy;
	
	float2 dd = frac(tex * size); 

	float4 c = lerp(
		lerp(tex2D(s0, tex), tex2D(s0, tex + dx), dd.x),
		lerp(tex2D(s0, tex + dy), tex2D(s0, tex + dxdy), dd.x),
		dd.y);
		
	return c;
}

static float4x4	tco =
{
	0, A, -2*A, A,
	1, 0, -A-3, A+2,
	0, -A, 2*A+3, -A-2,
	0, 0, A, -A
};

float4 taps(float x)
{
	return mul(tco, float4(1, x, x*x, x*x*x));
}

float4 SampleX(float4 tx, float2 tex)
{
	return
		mul(tx,
			float4x4(
				tex2D(s0, tex - dx),
				tex2D(s0, tex),
				tex2D(s0, tex + dx),
				tex2D(s0, tex + dx + dx)
			)
		);
}

float4 SampleY(float4 tx, float4 ty, float2 tex)
{
	return
		mul(ty,
			float4x4(
				SampleX(tx, tex - dy),
				SampleX(tx, tex),
				SampleX(tx, tex + dy),
				SampleX(tx, tex + dy + dy)
			)
		);
}

float4 main_bicubic(float2 tex : TEXCOORD0) : COLOR
{
	tex -= 0.49*dxdy; // at 0.5 nvidia cards show visible artifacts, sometimes...
	
	float2 dd = frac(tex * size);

	float4 tx = taps(dd.x);
	float4 ty = taps(dd.y);
	
	return SampleY(tx, ty, tex);
}

float4 main_bicubic_lut(float2 tex : TEXCOORD0) : COLOR
{
	tex -= 0.49*dxdy; // at 0.5 nvidia cards show visible artifacts, sometimes...

	float2 dd = frac(tex * size);

	float4 tx = tex1D(s1, dd.x);
	float4 ty = tex1D(s1, dd.y);

	return SampleY(tx, ty, tex);
}
